<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cairo by example</title>
    <link>https://cairo-by-example.com/</link>
    <description>Recent content on cairo by example</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Jun 2023 15:02:30 -0300</lastBuildDate><atom:link href="https://cairo-by-example.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>functions</title>
      <link>https://cairo-by-example.com/examples/functions/</link>
      <pubDate>Wed, 21 Jun 2023 15:02:30 -0300</pubDate>
      
      <guid>https://cairo-by-example.com/examples/functions/</guid>
      <description>A function is a unit of code that performs some logic. It is defined using the fn keyword.
Examples of functions are:
// This functions doesn&amp;#39;t return anything. fn main() { let x = 3; } // This function returns an u32. fn inc(x: u32) -&amp;gt; u32 { x + 1 } The Cairo convention is to name functions using the &amp;lsquo;snake_case&amp;rsquo; form. In the example above, the function name is inc_n.</description>
    </item>
    
    <item>
      <title>ownership</title>
      <link>https://cairo-by-example.com/examples/ownership/</link>
      <pubDate>Wed, 21 Jun 2023 14:08:27 -0300</pubDate>
      
      <guid>https://cairo-by-example.com/examples/ownership/</guid>
      <description>All Cairo code has to abide by two ownership rules: - each value in Cairo has one and only one owner at a time, - when the owner goes out of scope, the value will be dropped
use array::ArrayTrait; fn foo(arr: Array&amp;lt;u128&amp;gt;) { // foo takes ownership of the array. // when this function returns, arr is dropped. } fn main() { // as the creator of arr, the main function owns the array let arr = ArrayTrait::&amp;lt;u128&amp;gt;::new(); foo(arr); // moves ownership of the array to function call // foo(arr); &amp;lt;- fails to compile, as main doesn&amp;#39;t own the array anymore } </description>
    </item>
    
    <item>
      <title>comments</title>
      <link>https://cairo-by-example.com/examples/comments/</link>
      <pubDate>Wed, 21 Jun 2023 10:46:31 -0600</pubDate>
      
      <guid>https://cairo-by-example.com/examples/comments/</guid>
      <description>In Cairo programs, any text after a pair of forward slashes (//) and until the end of the line will be ignored by the compiler.
You can use this to leave explanatory comments in your code.
fn main() -&amp;gt; felt252 { // start of the function 1 + 4 // return the sum of 1 and 4 } </description>
    </item>
    
    <item>
      <title>structs</title>
      <link>https://cairo-by-example.com/examples/structs/</link>
      <pubDate>Wed, 21 Jun 2023 10:29:31 -0600</pubDate>
      
      <guid>https://cairo-by-example.com/examples/structs/</guid>
      <description>A struct is a collection of named fields. It is one of the ways to define custom user types.
The fields of a struct, called members, can be of any defined type.
For example:
struct Employee { age: u8, id: u32, role: String, } Struct members can be user-defined types:
struct Company { employees: Vec&amp;lt;Employee&amp;gt;, number_of_buildings: u32 } </description>
    </item>
    
    <item>
      <title>testing</title>
      <link>https://cairo-by-example.com/examples/testing/</link>
      <pubDate>Wed, 21 Jun 2023 11:22:00 -0300</pubDate>
      
      <guid>https://cairo-by-example.com/examples/testing/</guid>
      <description>Tests are functions that verify that code is working as expected. These functions have to be annotated with #[test]
Any code that panics will cause a test to fail. As a programmer you usually want to write a test by setting up an initial state, performing some computation, and asserting the result is as you expected.
For example:
#[test] fn test_passes() { let result = 2 + 2; assert(result == 4, &amp;#39;result is not 4&amp;#39;); } You can also annotate tests that are supposed to fail with #[should_panic]:</description>
    </item>
    
    <item>
      <title>zeroable</title>
      <link>https://cairo-by-example.com/examples/zeroable/</link>
      <pubDate>Wed, 21 Jun 2023 14:00:01 +0000</pubDate>
      
      <guid>https://cairo-by-example.com/examples/zeroable/</guid>
      <description>The Cairo std library has some utilities for handling non zero values.
Here is how to get a NonZero&amp;lt;T&amp;gt; out of a felt252.
// The IsZeroResult&amp;lt;T&amp;gt; enum allows us to obtain a NonZero&amp;lt;T&amp;gt; via matching. use zeroable::IsZeroResult; use zeroable::NonZeroIntoImpl; fn main() -&amp;gt; felt252 { // NonZeroIntoImpl converts a NonZero&amp;lt;T&amp;gt; into its inner value. NonZeroIntoImpl::into(felt_to_nonzero(1234)) } fn felt_to_nonzero(value: felt252) -&amp;gt; NonZero&amp;lt;felt252&amp;gt; { // felt252_is_zero is a builtin method for felt252. match felt252_is_zero(value) { IsZeroResult::Zero(()) =&amp;gt; panic(ArrayTrait::new()), IsZeroResult::NonZero(x) =&amp;gt; x, } } </description>
    </item>
    
    <item>
      <title>enums</title>
      <link>https://cairo-by-example.com/examples/enums/</link>
      <pubDate>Wed, 21 Jun 2023 13:28:01 +0000</pubDate>
      
      <guid>https://cairo-by-example.com/examples/enums/</guid>
      <description>An enum in Cairo works like a tagged union, variants can hold values inside, which you can access via pattern matching.
You can work with enums like this:
use option::Option; use option::OptionTrait; // Define an enum enum MyEnum { A: u8, B: u16, C: u32, D: u64 } // Construct and return an enum variant. fn my_enum_a() -&amp;gt; MyEnum { MyEnum::A(4_u8) } // Match the enum, the order must match the enum definition.</description>
    </item>
    
    <item>
      <title>operator overloading</title>
      <link>https://cairo-by-example.com/examples/op_overloading/</link>
      <pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://cairo-by-example.com/examples/op_overloading/</guid>
      <description>Operator overloading is possible in Cairo through the use of particular traits, like Add, Sub, Mul, Div and many others.
For example, for overloading the addition (+) operator of a Vector2 type:
struct Vector2 { x: f32, y: f32, } impl Vector2Add of Add&amp;lt;Vector2&amp;gt; { fn add(lhs: Vector2, rhs: Vector2) -&amp;gt; Vector2 { Vector2 { x: lhs.x + rhs.x, y: lhs.y + rhs.y } } } fn main() { let v = Vector2 { x: 1, y: 0 }; let w = Vector2 { x: 0, y: 1 }; assert(v + w == Vector2 { x: 1, y: 1 }, &amp;#39;Should be equal.</description>
    </item>
    
    <item>
      <title>assert</title>
      <link>https://cairo-by-example.com/examples/assert/</link>
      <pubDate>Sat, 10 Jun 2023 16:52:31 -0600</pubDate>
      
      <guid>https://cairo-by-example.com/examples/assert/</guid>
      <description>To make sure our tests work, we use assert.
fn main(x: felt252, y: felt252) { assert(x != y, &amp;#39;error, x is equal to y&amp;#39;); } #[test] fn test_main() { main(1,2); } The first argument of assert is the condition we want to check, and the second is a message we will see on the console if the condition is false.
Run cairo-test file_name
Try changing it so that the test fails.</description>
    </item>
    
    <item>
      <title>variables</title>
      <link>https://cairo-by-example.com/examples/variables/</link>
      <pubDate>Sat, 10 Jun 2023 16:52:31 -0600</pubDate>
      
      <guid>https://cairo-by-example.com/examples/variables/</guid>
      <description>To store data in variables with the let keyword but you will not be able to change the value of said variables.
if you need to change that data, it must be a mutable variable with let mut
fn main() { let immutable_var: felt252 = 17; // immutable_var = 38; &amp;lt;-- fails to compile // but this is legal: let mut mutable_var: felt252 = immutable_var; mutable_var = 38; assert(mutable_var != immutable_var, &amp;#39;mutable equals immutable&amp;#39;); } #[test] fn test_main() { main(); } </description>
    </item>
    
    <item>
      <title>hello world</title>
      <link>https://cairo-by-example.com/examples/hello-world/</link>
      <pubDate>Sat, 10 Jun 2023 16:52:30 -0600</pubDate>
      
      <guid>https://cairo-by-example.com/examples/hello-world/</guid>
      <description>the use keyword imports a dependency into scope
use debug::PrintTrait; fn main() { &amp;#34;Hello, world!&amp;#34;.print(); } now, run the tests with cairo-run hello_world.cairo
[DEBUG]	Hello, world! (raw: 0x48656c6c6f2c20776f726c6421 Run completed successfully, returning [] </description>
    </item>
    
  </channel>
</rss>
